<div class="lstm-train-container">
  <h2>Train LSTM Model</h2>
  <p class="subtitle">Configure and train an LSTM neural network for stock price prediction.</p>

  <!-- Config Form -->
  <div class="config-form">
    <div class="form-row">
      <div class="form-group">
        <label for="ticker">Ticker</label>
        <input
          id="ticker"
          type="text"
          [ngModel]="ticker()"
          (ngModelChange)="ticker.set($event)"
          placeholder="e.g. AAPL"
        />
      </div>
      <div class="form-group">
        <label for="fromDate">From Date</label>
        <input
          id="fromDate"
          type="date"
          [ngModel]="fromDate()"
          (ngModelChange)="fromDate.set($event)"
        />
      </div>
      <div class="form-group">
        <label for="toDate">To Date</label>
        <input
          id="toDate"
          type="date"
          [ngModel]="toDate()"
          (ngModelChange)="toDate.set($event)"
        />
      </div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label for="epochs">Epochs</label>
        <input
          id="epochs"
          type="number"
          [ngModel]="epochs()"
          (ngModelChange)="epochs.set($event)"
          min="1"
          max="500"
        />
      </div>
      <div class="form-group">
        <label for="seqLen">Sequence Length</label>
        <input
          id="seqLen"
          type="number"
          [ngModel]="sequenceLength()"
          (ngModelChange)="sequenceLength.set($event)"
          min="10"
          max="200"
        />
      </div>
      <div class="form-group">
        <label for="features">Features</label>
        <select
          id="features"
          [ngModel]="features()"
          (ngModelChange)="features.set($event)"
        >
          @for (f of featureOptions; track f) {
            <option [value]="f">{{ f }}</option>
          }
        </select>
      </div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label for="scalerType">Scaler</label>
        <select
          id="scalerType"
          [ngModel]="scalerType()"
          (ngModelChange)="scalerType.set($event)"
        >
          @for (s of scalerOptions; track s.value) {
            <option [value]="s.value">{{ s.label }}</option>
          }
        </select>
      </div>
      <div class="form-group">
        <label for="timespan">Timespan</label>
        <select
          id="timespan"
          [ngModel]="timespan()"
          (ngModelChange)="timespan.set($event)"
        >
          @for (t of timespanOptions; track t.value) {
            <option [value]="t.value">{{ t.label }}</option>
          }
        </select>
      </div>
      <div class="form-group">
        <label for="multiplier">Multiplier</label>
        <input
          id="multiplier"
          type="number"
          [ngModel]="multiplier()"
          (ngModelChange)="multiplier.set($event)"
          min="1"
          max="60"
        />
      </div>
    </div>

    <div class="form-row">
      <div class="form-group checkbox-group">
        <label>
          <input
            type="checkbox"
            [ngModel]="logReturns()"
            (ngModelChange)="logReturns.set($event)"
          />
          Log Returns
        </label>
      </div>
      <div class="form-group checkbox-group">
        <label>
          <input
            type="checkbox"
            [ngModel]="winsorize()"
            (ngModelChange)="winsorize.set($event)"
          />
          Winsorize
        </label>
      </div>
      <div class="form-group checkbox-group">
        <label>
          <input
            type="checkbox"
            [ngModel]="mock()"
            (ngModelChange)="mock.set($event)"
          />
          Mock Data
        </label>
      </div>
      <div class="form-group data-estimate">
        <span class="estimate-label">Est. data points:</span>
        <span class="estimate-value">~{{ dataPointEstimate() | number }}</span>
      </div>
    </div>

    <div class="form-actions">
      <button
        class="train-button"
        (click)="startTraining()"
        [disabled]="loading()"
      >
        @if (loading()) {
          <span class="spinner"></span> Training...
        } @else {
          Start Training
        }
      </button>
      <button
        class="help-toggle"
        (click)="showHelp.set(!showHelp())"
      >
        {{ showHelp() ? 'Hide' : 'Show' }} setting guide
      </button>
    </div>
  </div>

  <!-- Help Section -->
  @if (showHelp()) {
    <div class="help-section">
      <h4>How Settings Affect Training</h4>

      <div class="help-item">
        <strong>Duration (From/To Date)</strong>
        <p>More data gives the model more patterns to learn, but older data may not reflect current market conditions. Your Polygon Starter plan provides up to 2 years of historical data.</p>
      </div>

      <div class="help-item">
        <strong>Timespan & Multiplier</strong>
        <p>Controls data density. Day = ~252 bars/year. Hour = ~1,638/year. Minute = ~98,280/year. Higher density reveals intraday patterns but significantly increases training time. Use multiplier for coarser bins (e.g., timespan "minute" + multiplier 5 = 5-minute bars).</p>
      </div>

      <div class="help-item">
        <strong>Epochs</strong>
        <p>Number of complete passes through the training data. More epochs means better learning but risks overfitting. Watch for validation loss rising while training loss falls (visible in the loss chart). Early stopping is applied automatically. Typical range: 20-100.</p>
      </div>

      <div class="help-item">
        <strong>Sequence Length</strong>
        <p>How many past bars the model examines to predict the next value. Should be less than 25% of total data points. For daily data over 2 years (~504 bars), 60 is a good default. For minute data (~98K bars), you can increase to 120+.</p>
      </div>

      <div class="help-item">
        <strong>Features</strong>
        <p>More features provide more information but make the model harder to train. "close" alone is simplest. Adding "volume" helps detect price-volume divergences. "log_return" improves stationarity. Avoid adding features you don't understand.</p>
      </div>

      <div class="help-item">
        <strong>Scaler</strong>
        <p>Standard (z-score) works best for normally distributed data. Robust uses median/IQR, making it better when outliers exist (earnings gaps, flash crashes). MinMax constrains to [0,1] but is sensitive to outliers.</p>
      </div>

      <div class="help-item">
        <strong>Log Returns</strong>
        <p>Transforms raw prices into percentage changes: log(price_t / price_t-1). This makes the data more stationary, which is critical for LSTM learning. Recommended when using raw price features.</p>
      </div>

      <div class="help-item">
        <strong>Winsorize</strong>
        <p>Clips extreme values at the 1st and 99th percentile. Prevents outliers from dominating the scaler. Recommended when your data contains price spikes or gaps.</p>
      </div>
    </div>
  }

  <!-- Status -->
  @if (status()) {
    <div class="status-section">
      <span class="status-badge" [class]="'status-' + status()">
        {{ status() }}
      </span>
      @if (jobId()) {
        <span class="job-id">Job: {{ jobId() }}</span>
      }
    </div>
  }

  <!-- Error -->
  @if (error()) {
    <div class="error-message">{{ error() }}</div>
  }

  <!-- Results -->
  @if (result(); as r) {
    <div class="results-section">
      <h3>Training Results</h3>

      <!-- Metrics Cards -->
      <div class="metrics-grid">
        <div class="metric-card">
          <span class="metric-label">Validation RMSE</span>
          <span class="metric-value">{{ r.valRmse.toFixed(4) }}</span>
        </div>
        <div class="metric-card">
          <span class="metric-label">Baseline RMSE</span>
          <span class="metric-value">{{ r.baselineRmse.toFixed(4) }}</span>
        </div>
        <div class="metric-card" [class.positive]="improvementPositive()" [class.negative]="!improvementPositive()">
          <span class="metric-label">Improvement</span>
          <span class="metric-value">{{ r.improvement.toFixed(2) }}%</span>
        </div>
        <div class="metric-card">
          <span class="metric-label">Train RMSE</span>
          <span class="metric-value">{{ r.trainRmse.toFixed(4) }}</span>
        </div>
        <div class="metric-card">
          <span class="metric-label">Best Epoch</span>
          <span class="metric-value">{{ r.bestEpoch }} / {{ r.epochsCompleted }}</span>
        </div>
        <div class="metric-card">
          <span class="metric-label">Model ID</span>
          <span class="metric-value small">{{ r.modelId }}</span>
        </div>
      </div>

      <!-- Stationarity Card -->
      @if (r.stationarityIsStationary !== null) {
        <div class="stationarity-card" [class.stationary]="stationarityIsGood" [class.non-stationary]="!stationarityIsGood">
          <div class="stationarity-header">
            <strong>Stationarity: {{ stationarityStatus }}</strong>
          </div>
          <div class="stationarity-details">
            <span>ADF p-value: {{ r.stationarityAdfPvalue?.toFixed(4) }}</span>
            <span>KPSS p-value: {{ r.stationarityKpssPvalue?.toFixed(4) }}</span>
          </div>
          @if (!stationarityIsGood) {
            <p class="stationarity-hint">Data appears non-stationary. Consider enabling Log Returns or using differenced features for better results.</p>
          }
        </div>
      }

      @if (!improvementPositive()) {
        <div class="warning-banner">
          Model did not outperform the naive baseline. Consider adjusting hyperparameters or adding more data.
        </div>
      }

      <!-- Charts -->
      <div class="chart-section">
        <h4>Actual vs Predicted</h4>
        <app-prediction-chart [actual]="r.actualValues" [predicted]="r.predictedValues" />
      </div>

      <div class="chart-section">
        <h4>Training & Validation Loss</h4>
        <app-training-history-chart [historyLoss]="r.historyLoss" [historyValLoss]="r.historyValLoss" />
      </div>

      <div class="chart-section">
        <h4>Residuals Distribution</h4>
        <app-residuals-chart [residuals]="r.residuals" />
      </div>
    </div>
  }
</div>
